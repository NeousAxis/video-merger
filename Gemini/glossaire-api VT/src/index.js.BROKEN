// API Glossaire Simple - Version avec Stripe
// Pour Cloudflare Workers
import Stripe from 'stripe';



export default {
  async fetch(request, env, ctx) {
    // Configuration CORS
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*', 
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, X-API-Key',
    };

    // Gestion OPTIONS pour CORS
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      const url = new URL(request.url);
      const path = url.pathname;
      const method = request.method;

      // Route publique principale
      // Route publique principale pour le formulaire d'inscription
      if ((path === '/' || path === '/register') && method === 'GET') {
        const registrationFormHtml = "<!DOCTYPE html>\n<html lang=\"fr\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>API Glossaire - Obtenir une cl√© API</title>\n   <style>\n       * { margin: 0; padding: 0; box-sizing: border-box; }\n       body {\n           font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n           background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n           min-height: 100vh;\n           display: flex;\n           align-items: center;\n           justify-content: center;\n           padding: 20px;\n       }\n       .container {\n           background: white;\n           border-radius: 16px;\n           box-shadow: 0 20px 40px rgba(0,0,0,0.1);\n           max-width: 500px;\n           width: 100%;\n           overflow: hidden;\n       }\n       .header {\n           background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);\n           color: white;\n           padding: 2rem;\n           text-align: center;\n       }\n       .header h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }\n       .form-container { padding: 2rem; }\n       .form-group { margin-bottom: 1.5rem; }\n       label { display: block; margin-bottom: 0.5rem; font-weight: 500; }\n       input, select { width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; }\n       .btn { width: 100%; background: #4f46e5; color: white; border: none; padding: 0.875rem; border-radius: 8px; cursor: pointer; }\n   </style>\n</head>\n<body>\n   <div class=\"container\">\n       <div class=\"header\">\n           <h1> API Glossaire</h1>\n           <p>Acc√©dez √† notre base de connaissances philosophiques</p>\n       </div>\n       <div class=\"form-container\">\n           <form id=\"apiKeyForm\">\n               <div class=\"form-group\">\n                   <label for=\"name\">Nom de votre projet *</label>\n                   <input type=\"text\" id=\"name\" required placeholder=\"Mon Bot IA\">\n               </div>\n               <div class=\"form-group\">\n                   <label for=\"email\">Email *</label>\n                   <input type=\"email\" id=\"email\" required placeholder=\"votre@email.com\">\n               </div>\n               <div class=\"form-group\">\n                   <label for=\"plan\">Plan</label>\n                   <select id=\"plan\">\n                       <option value=\"gratuit\">Gratuit - 1 000 appels/jour</option>\n                       <option value=\"starter\">Starter - 20 000 appels/jour</option>\n                   </select>\n               </div>\n               <button type=\"submit\" class=\"btn\">Obtenir ma cl√© API</button>\n           </form>\n           <div id=\"result\" style=\"margin-top: 1rem; display: none; padding: 1rem; border-radius: 8px;\"></div>\n       </div>\n   </div>\n   <script>\n       document.getElementById('apiKeyForm').addEventListener('submit', async (e) => {\n           e.preventDefault();\n           const formData = {\n               name: document.getElementById('name').value,\n               email: document.getElementById('email').value,\n               plan: document.getElementById('plan').value\n           };\n           \n           const response = await fetch('/api/register', {\n               method: 'POST',\n               headers: { 'Content-Type': 'application/json' },\n               body: JSON.stringify(formData)\n           });\n           \n           const result = await response.json();\n           const resultDiv = document.getElementById('result');\n           \n           if (response.ok) {\n               resultDiv.innerHTML = `<h3> Succ√®s</h3><p>Votre cl√© API a √©t√© g√©n√©r√©e. Veuillez v√©rifier votre email.</p>`;\n               resultDiv.style.background = '#ecfdf5';\n               resultDiv.style.color = '#065f46';\n           } else {\n               resultDiv.innerHTML = `<h3>‚ùå Erreur</h3><p>${result.error}</p>`;\n               resultDiv.style.background = '#fef2f2';\n               resultDiv.style.color = '#991b1b';\n           }\n           resultDiv.style.display = 'block';\n       });\n   </script>\n</body>\n</html>";
        return new Response(registrationFormHtml, {
          headers: { 'Content-Type': 'text/html; charset=utf-8' },
        });
      }

      // Route publique pour l'inscription (AVANT l'authentification)
      if (path === '/api/register' && method === 'POST') {
        return await handleRegister(request, env, corsHeaders);
      }

      // Authentification et limitation de requ√™tes pour toutes les autres routes API
      if (path.startsWith('/api/') && path !== '/api/register') {
        const authResult = await authenticateRequest(request, env, corsHeaders);
        if (authResult instanceof Response) {
          return authResult;
        }

        const rateLimitResponse = await applyRateLimiting(request, env, authResult, corsHeaders);
        if (rateLimitResponse) {
          return rateLimitResponse;
        }
      }

      

      // Route pour cr√©er une intention de paiement Stripe
      if (path === '/api/create-payment-intent' && method === 'POST') {
        return await handleCreatePaymentIntent(request, env, corsHeaders);
      }

      // Route pour l'inscription et la g√©n√©ration de cl√© API
      if (path === '/api/register' && method === 'POST') {
        return await handleRegister(request, env, corsHeaders);
      }

      

      // --- Routes du glossaire ---
      if (path === '/api/terms' && method === 'GET') {
        return await getAllTerms(env, corsHeaders);
      }
      if (path === '/api/search' && method === 'GET') {
        const query = url.searchParams.get('q');
        return await searchTerms(query, env, corsHeaders);
      }
      if (path === '/api/terms' && method === 'POST') {
        return await addTerm(request, env, corsHeaders);
      }
      if (path.startsWith('/api/terms/') && method === 'PUT') {
        const id = path.split('/').pop();
        return await updateTerm(id, request, env, corsHeaders);
      }
      if (path.startsWith('/api/terms/') && method === 'DELETE') {
        const id = path.split('/').pop();
        return await deleteTerm(id, env, corsHeaders);
      }

      // Route non trouv√©e
      return new Response(JSON.stringify({ error: "Route non trouv√©e" }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });

    } catch (error) {
      console.error('Erreur dans l\'API:', error);
      return new Response(JSON.stringify({ error: "Erreur serveur", message: error.message }), {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
  }
};

// üí≥ FONCTION: G√©rer la cr√©ation d'une intention de paiement Stripe
async function handleCreatePaymentIntent(request, env, corsHeaders) {
    try {
        const stripe = new Stripe(env.STRIPE_API_KEY);
        
        // Pour l'instant, on utilise un montant fixe.
        // Plus tard, on pourra le r√©cup√©rer depuis le corps de la requ√™te.
        const body = await request.json().catch(() => ({})); // Accepte un corps vide

        const amount = body.amount || 1000; // 10.00 EUR par d√©faut
        const currency = body.currency || 'eur';

        const paymentIntent = await stripe.paymentIntents.create({
            amount: amount,
            currency: currency,
            payment_method_types: ['card'],
        });

        return new Response(JSON.stringify({
            clientSecret: paymentIntent.client_secret
        }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });

    } catch (error) {
        console.error("Erreur Stripe:", error);
        return new Response(JSON.stringify({ error: "Erreur lors de la cr√©ation du paiement", details: error.message }), {
            status: 500,
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
    }
}




// üîë FONCTION: G√©rer l'inscription et la g√©n√©ration de cl√© API
async function handleRegister(request, env, corsHeaders) {
  try {
    const body = await request.json();
    const { name, email, plan } = body;
    
    console.log('Donn√©es re√ßues:', { name, email, plan });
    
    if (!name || !trimmedEmail) {
      return new Response(JSON.stringify({
        error: 'Nom et email requis'
      }), { 
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    const apiKey = `gls_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    
    const userData = {
      api_key: apiKey,
      name,
      email: trimmedEmail,
      plan: plan || 'gratuit',
      created_at: new Date().toISOString(),
      quota_daily: plan === 'starter' ? 20000 : 1000,
      usage_today: 0,
      last_reset: new Date().toISOString().split('T')[0]
    };

    console.log('Cr√©ation cl√© API:', apiKey, 'pour', trimmedEmail);
    
    console.log('Tentative de stockage dans KV:', trimmedEmail, JSON.stringify(userData));
    await env.API_KEYS.put(trimmedEmail, JSON.stringify(userData));
    console.log('Stockage KV termin√© pour:', trimmedEmail);

    return new Response(JSON.stringify({
      success: true,
      api_key: apiKey,
      plan: userData.plan,
      quota: userData.quota_daily,
      message: 'Cl√© API cr√©√©e avec succ√®s'
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Erreur handleRegister:', error);
    return new Response(JSON.stringify({
      error: 'Erreur: ' + error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}



// üîí FONCTION: Authentification par cl√© API
async function authenticateRequest(request, env, corsHeaders) {
  const apiKey = request.headers.get('X-API-Key');
  if (!apiKey) {
    return new Response(JSON.stringify({ error: "Cl√© API manquante. Veuillez fournir l'en-t√™te 'X-API-Key'." }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  try {
    const keyDetailsStr = await env.API_KEYS.get(apiKey);
    if (!keyDetailsStr) {
      return new Response(JSON.stringify({ error: "Cl√© API invalide." }), {
        status: 401,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    const keyDetails = JSON.parse(keyDetailsStr);
    if (!keyDetails.active) {
        return new Response(JSON.stringify({ error: "Cl√© API inactive." }), {
            status: 403,
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
    }
    return { apiKey, keyDetails };
  } catch (e) {
    return new Response(JSON.stringify({ error: "Erreur lors de la validation de la cl√© API." }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// ‚è±Ô∏è FONCTION: Limitation de requ√™tes
async function applyRateLimiting(request, env, authResult, corsHeaders) {
    const { apiKey, keyDetails } = authResult;
    const { rateLimit } = keyDetails;
    if (!rateLimit) return null;
    const currentTime = Math.floor(Date.now() / 1000);
    const windowStart = keyDetails.rateLimit.timestamp || 0;
    let count = keyDetails.rateLimit.count || 0;
    if (currentTime - windowStart > rateLimit.window) {
        count = 1;
        keyDetails.rateLimit.timestamp = currentTime;
    } else {
        count++;
    }
    if (count > rateLimit.limit) {
        return new Response(JSON.stringify({ error: "Limite de requ√™tes atteinte. R√©essayez plus tard." }), {
            status: 429,
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
    }
    keyDetails.rateLimit.count = count;
    await env.API_KEYS.put(apiKey, JSON.stringify(keyDetails));
    return null;
}

// --- FONCTIONS DU GLOSSAIRE ---

async function getAllTerms(env, corsHeaders) {
  try {
    const termsList = await env.GLOSSARY_TERMS.get('terms_index');
    if (!termsList) {
      return new Response(JSON.stringify({ terms: [], count: 0, message: "Aucun terme trouv√©." }), {
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    const termsIds = JSON.parse(termsList);
    const terms = [];
    for (const id of termsIds) {
      const termData = await env.GLOSSARY_TERMS.get(id);
      if (termData) {
        terms.push(JSON.parse(termData));
      }
    }
    return new Response(JSON.stringify({ terms: terms, count: terms.length }), {
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: "Erreur lors de la r√©cup√©ration des termes", message: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

async function searchTerms(query, env, corsHeaders) {
  if (!query || query.trim() === '') {
    return new Response(JSON.stringify({ error: "Param√®tre 'q' requis" }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  try {
    const termsList = await env.GLOSSARY_TERMS.get('terms_index');
    if (!termsList) {
      return new Response(JSON.stringify({ query: query, results: [], count: 0 }), {
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    const termsIds = JSON.parse(termsList);
    const results = [];
    for (const id of termsIds) {
      const termData = await env.GLOSSARY_TERMS.get(id);
      if (termData) {
        const term = JSON.parse(termData);
        const searchTerm = query.toLowerCase();
        if (term.terme.toLowerCase().includes(searchTerm) || term.definition.toLowerCase().includes(searchTerm)) {
          results.push(term);
        }
      }
    }
    return new Response(JSON.stringify({ query: query, results: results, count: results.length }), {
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: "Erreur lors de la recherche", message: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

async function addTerm(request, env, corsHeaders) {
  try {
    const body = await request.json();
    if (!body.terme || !body.definition) {
      return new Response(JSON.stringify({ error: "Donn√©es manquantes", required: ["terme", "definition"] }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    const id = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const newTerm = {
      id: id,
      terme: body.terme.trim(),
      definition: body.definition.trim(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    await env.GLOSSARY_TERMS.put(`term_${id}`, JSON.stringify(newTerm));
    const existingIndex = await env.GLOSSARY_TERMS.get('terms_index');
    const termsIds = existingIndex ? JSON.parse(existingIndex) : [];
    termsIds.push(id);
    await env.GLOSSARY_TERMS.put('terms_index', JSON.stringify(termsIds));
    return new Response(JSON.stringify({ message: "Terme ajout√© avec succ√®s", term: newTerm }), {
      status: 201,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: "Erreur lors de l\'ajout", message: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

async function updateTerm(id, request, env, corsHeaders) {
  try {
    const existingTerm = await env.GLOSSARY_TERMS.get(`term_${id}`);
    if (!existingTerm) {
      return new Response(JSON.stringify({ error: "Terme non trouv√©" }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    const body = await request.json();
    const currentTerm = JSON.parse(existingTerm);
    const updatedTerm = {
      ...currentTerm,
      terme: body.terme ? body.terme.trim() : currentTerm.terme,
      definition: body.definition ? body.definition.trim() : currentTerm.definition,
      updated_at: new Date().toISOString()
    };
    await env.GLOSSARY_TERMS.put(`term_${id}`, JSON.stringify(updatedTerm));
    return new Response(JSON.stringify({ message: "Terme modifi√© avec succ√®s", term: updatedTerm }), {
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: "Erreur lors de la modification", message: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

async function deleteTerm(id, request, env, corsHeaders) {
  try {
    const existingTerm = await env.GLOSSARY_TERMS.get(`term_${id}`);
    if (!existingTerm) {
      return new Response(JSON.stringify({ error: "Terme non trouv√©" }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    await env.GLOSSARY_TERMS.delete(`term_${id}`);
    const existingIndex = await env.GLOSSARY_TERMS.get('terms_index');
    if (existingIndex) {
      const termsIds = JSON.parse(existingIndex);
      const filteredIds = termsIds.filter(termId => termId !== id);
      await env.GLOSSARY_TERMS.put('terms_index', JSON.stringify(filteredIds));
    }
    return new Response(JSON.stringify({ message: "Terme supprim√© avec succ√®s" }), {
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: "Erreur lors de la suppression", message: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}


